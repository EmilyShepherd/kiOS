#!/bin/busybox sh
#
#
#
#

BB=/bin/busybox
CRIO_SOCK=/var/run/crio/crio.sock
KUBELET_CONFIG=/var/lib/kubelet/config.yaml

wait_for_file() {
  while ! test -e $1; do $BB sleep 1; done
}

/bin/crio >/var/log/crio.log 2>&1 &

wait_for_file $CRIO_SOCK

if test -f $KUBELET_CONFIG
then
  # Make sure our init pods does _not_ run for subsequent boots of the
  # node.
  $BB rm /etc/kubernetes/manifests/init.yaml
else
  # If there is no config for the kubelet, we have to start up in
  # standalone mode. The default installation includes a static pod to
  # bootstrap the cluster.
  $BB cp /static/init.yaml /etc/kubernetes/manifests/

  kubelet --container-runtime remote \
    --container-runtime-endpoint unix:///var/run/crio/crio.sock \
    --pod-manifest-path=/etc/kubernetes/manifests &

  kubeletpid=$!

  wait_for_file $KUBELET_CONFIG
  kill $kubeletpid
fi

kubelet \
  --config $KUBELET_CONFIG \
  --kubeconfig /etc/kubernetes/kubelet.conf \
  --bootstrap-kubeconfig /etc/kubernetes/bootstrap-kubelet.conf \
  --container-runtime remote \
  --container-runtime-endpoint unix:///var/run/crio/crio.sock \
  >/var/log/kubelet.log 2>&1
